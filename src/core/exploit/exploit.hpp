#pragma once
#include "dependencies/std_include.hpp"

namespace exploit
{
	namespace instant_message
	{
		void send_popup(const uint64_t xuid);
		void send_info_response_overflow(const uint64_t xuid);
		void send_friend_message_crash(const uint64_t xuid);
	}

	namespace lobby_msg
	{
		bool send_client_disconnect(const game::netadr_t& netadr, const game::LobbyType type, const std::uint64_t xuid);
		void send_disconnect_client(const game::LobbySession* session, const std::uint64_t xuid);
		void send_client_content_crash(const game::LobbySession* session, const game::netadr_t& netadr, const uint64_t xuid);
	}
	
	void send_connect_from_lobby(const game::netadr_t& netadr, const uint64_t xuid);
	void send_connect_response_migration_packet(const game::netadr_t & to);
	void send_mstart_packet(const game::netadr_t & to);
	void send_request_stats_packet(const game::netadr_t & to);
	void send_lost_reliable_cmds_kick(const game::netadr_t& netadr, const uint64_t xuid);
	void send_update_svcmd_overflow(const game::netadr_t& netadr, const uint64_t xuid);
	void send_invalid_cmd_sequence_crash(const game::netadr_t& netadr, const uint64_t xuid);
	void send_sv_gamestate_crash(const game::netadr_t& netadr, const uint64_t xuid);
	void send_netchan_freeze(const game::netadr_t& netadr);
	void send_crash(const game::netadr_t & netadr, const std::uint64_t xuid = 0, const bool freeze = false);
}